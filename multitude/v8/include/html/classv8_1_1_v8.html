<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>v8: v8::V8 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacev8.html">v8</a>::<a class="el" href="classv8_1_1_v8.html">V8</a>
  </div>
</div>
<div class="contents">
<h1>v8::V8 Class Reference</h1><!-- doxytag: class="v8::V8" --><code>#include &lt;<a class="el" href="v8_8h-source.html">v8.h</a>&gt;</code>
<p>

<p>
<a href="classv8_1_1_v8-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#b386f81a6d58dcf481d00446e8d15c9e">SetFatalErrorHandler</a> (FatalErrorCallback that)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#1058ff39b32a17976df1e2b75c3d1cb4">IgnoreOutOfMemoryException</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#0d5593ecf0d41035e4d9ee512119f0b7">IsDead</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#125dadf8feb6178a42333f2a6412ea73">AddMessageListener</a> (MessageCallback that, <a class="el" href="classv8_1_1_handle.html">Handle</a>&lt; <a class="el" href="classv8_1_1_value.html">Value</a> &gt; data=<a class="el" href="classv8_1_1_handle.html">Handle</a>&lt; <a class="el" href="classv8_1_1_value.html">Value</a> &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#024f57744e8dfdcb2ea1417024b4805c">RemoveMessageListeners</a> (MessageCallback that)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#b263a85e6f97ea79d944bd20bb09a95f">SetFlagsFromString</a> (const char *str, int length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#63157ad9284ffad1c0ab62b21aadd08c">SetFlagsFromCommandLine</a> (int *argc, char **argv, bool remove_flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#fcecc0e9e8b5fa17a06a93f7b5a7538d">GetVersion</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#830d3ba2704b6e7c361188b22318c0be">SetCounterFunction</a> (CounterLookupCallback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#c4db0dff0f29c750d30fcac65c4d1968">SetCreateHistogramFunction</a> (CreateHistogramCallback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cbd552ca4282f1a7648c221aa70ff93e"></a><!-- doxytag: member="v8::V8::SetAddHistogramSampleFunction" ref="cbd552ca4282f1a7648c221aa70ff93e" args="(AddHistogramSampleCallback)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetAddHistogramSampleFunction</b> (AddHistogramSampleCallback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#a91df5fe1bb98b87952ef4bbf0aceb96">EnableSlidingStateWindow</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#a6ed646d43360c209881871b3ac747aa">SetFailedAccessCheckCallbackFunction</a> (FailedAccessCheckCallback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#49c016f17c67f700387f801b2b29b5ab">AddGCPrologueCallback</a> (GCPrologueCallback callback, <a class="el" href="namespacev8.html#c109d6f27e0c0f9ef4e98bcf7a806cf2">GCType</a> gc_type_filter=kGCTypeAll)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#7cdceb9c8ea5cd0887f69fd3bd97193f">RemoveGCPrologueCallback</a> (GCPrologueCallback callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#503e14a77e922775bd88bc2e19e19886">SetGlobalGCPrologueCallback</a> (GCCallback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#37aadf3536c772eb5bbf67fa7822679a">AddGCEpilogueCallback</a> (GCEpilogueCallback callback, <a class="el" href="namespacev8.html#c109d6f27e0c0f9ef4e98bcf7a806cf2">GCType</a> gc_type_filter=kGCTypeAll)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#3382e4dae9865909242a8ee0b1d6bf77">RemoveGCEpilogueCallback</a> (GCEpilogueCallback callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#94bac5e06a99141c5629842e18558cfe">SetGlobalGCEpilogueCallback</a> (GCCallback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#4744037e970e3b3bafcc3cac03a5967f">AddObjectGroup</a> (<a class="el" href="classv8_1_1_persistent.html">Persistent</a>&lt; <a class="el" href="classv8_1_1_value.html">Value</a> &gt; *objects, size_t length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#40daec93ce44bdd922567fc121be9db8">Initialize</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#8e6f2e66c028d1ffa3f5e8a799790bc5">AdjustAmountOfExternalAllocatedMemory</a> (int change_in_bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#5fefebea0cd37105837a9d267baf2e5c">PauseProfiler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#b0557aaba62c7fb253fe838003aa60af">ResumeProfiler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#a8dc5a7c3a059bb376882ac36b9df775">IsProfilerPaused</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#ffe7a421288278719a71928d3b9c4836">ResumeProfilerEx</a> (int flags, int tag=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#8078e3c6e4d38ef6e9142b76b0420d4e">PauseProfilerEx</a> (int flags, int tag=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#94e8ce52e976b58d5cbdb23d2abe894e">GetActiveProfilerModules</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#c7e91e25ed7773db1f31413fb726bca7">GetLogLines</a> (int from_pos, char *dest_buf, int max_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#6b73813e84728c2a91f61ef45e48d80c">GetCurrentThreadId</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#f7d845e6f55eb76085d5ff3601780986">TerminateExecution</a> (int thread_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#7b09bb56f4effb91e1de4398c8fd43f2">TerminateExecution</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#eeffbebf5f753286eda3db8f14908ad7">IsExecutionTerminating</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#566450d632c0a63770682b9da3cae08d">Dispose</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#63e014365648e568ae47b8a849dfc992">GetHeapStatistics</a> (<a class="el" href="classv8_1_1_heap_statistics.html">HeapStatistics</a> *heap_statistics)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#f4ac685c915acf6325daafa70bae9835">IdleNotification</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#7df118b9667d04903f8e9fb7452fd1ac">LowMemoryNotification</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#06126bd2345c086a376f934ec1fbcce6">ContextDisposedNotification</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classv8_1_1_v8.html#2bdde078c68d2820262925687b962553">kMinimumSizeForLogLinesBuffer</a> = 2048</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9470c7f2c90465ee28ee0cd19af986ea"></a><!-- doxytag: member="v8::V8::Handle" ref="9470c7f2c90465ee28ee0cd19af986ea" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Handle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0320da7f4056d4493dc1f8e49985d06e"></a><!-- doxytag: member="v8::V8::Local" ref="0320da7f4056d4493dc1f8e49985d06e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Local</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f9b9166ff006dd19d2335aaf93aa937"></a><!-- doxytag: member="v8::V8::Persistent" ref="3f9b9166ff006dd19d2335aaf93aa937" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Persistent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c26c806e60ca4a0547680edb68f6e39b"></a><!-- doxytag: member="v8::V8::Context" ref="c26c806e60ca4a0547680edb68f6e39b" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Context</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Container class for static utility functions. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="37aadf3536c772eb5bbf67fa7822679a"></a><!-- doxytag: member="v8::V8::AddGCEpilogueCallback" ref="37aadf3536c772eb5bbf67fa7822679a" args="(GCEpilogueCallback callback, GCType gc_type_filter=kGCTypeAll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::AddGCEpilogueCallback           </td>
          <td>(</td>
          <td class="paramtype">GCEpilogueCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacev8.html#c109d6f27e0c0f9ef4e98bcf7a806cf2">GCType</a>&nbsp;</td>
          <td class="paramname"> <em>gc_type_filter</em> = <code>kGCTypeAll</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the host application to receive a notification after a garbage collection. Allocations are not allowed in the callback function, you therefore cannot manipulate objects (set or delete properties for example) since it is possible such operations will result in the allocation of objects. It is possible to specify the GCType filter for your callback. But it is not possible to register the same callback function two times with different GCType filters. 
</div>
</div><p>
<a class="anchor" name="49c016f17c67f700387f801b2b29b5ab"></a><!-- doxytag: member="v8::V8::AddGCPrologueCallback" ref="49c016f17c67f700387f801b2b29b5ab" args="(GCPrologueCallback callback, GCType gc_type_filter=kGCTypeAll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::AddGCPrologueCallback           </td>
          <td>(</td>
          <td class="paramtype">GCPrologueCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacev8.html#c109d6f27e0c0f9ef4e98bcf7a806cf2">GCType</a>&nbsp;</td>
          <td class="paramname"> <em>gc_type_filter</em> = <code>kGCTypeAll</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the host application to receive a notification before a garbage collection. Allocations are not allowed in the callback function, you therefore cannot manipulate objects (set or delete properties for example) since it is possible such operations will result in the allocation of objects. It is possible to specify the GCType filter for your callback. But it is not possible to register the same callback function two times with different GCType filters. 
</div>
</div><p>
<a class="anchor" name="125dadf8feb6178a42333f2a6412ea73"></a><!-- doxytag: member="v8::V8::AddMessageListener" ref="125dadf8feb6178a42333f2a6412ea73" args="(MessageCallback that, Handle&lt; Value &gt; data=Handle&lt; Value &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::AddMessageListener           </td>
          <td>(</td>
          <td class="paramtype">MessageCallback&nbsp;</td>
          <td class="paramname"> <em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classv8_1_1_handle.html">Handle</a>&lt; <a class="el" href="classv8_1_1_value.html">Value</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>data</em> = <code><a class="el" href="classv8_1_1_handle.html">Handle</a>&lt;&nbsp;<a class="el" href="classv8_1_1_value.html">Value</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a message listener.<p>
The same message listener can be added more than once and it that case it will be called more than once for each message. 
</div>
</div><p>
<a class="anchor" name="4744037e970e3b3bafcc3cac03a5967f"></a><!-- doxytag: member="v8::V8::AddObjectGroup" ref="4744037e970e3b3bafcc3cac03a5967f" args="(Persistent&lt; Value &gt; *objects, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::AddObjectGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classv8_1_1_persistent.html">Persistent</a>&lt; <a class="el" href="classv8_1_1_value.html">Value</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows the host application to group objects together. If one object in the group is alive, all objects in the group are alive. After each garbage collection, object groups are removed. It is intended to be used in the before-garbage-collection callback function, for instance to simulate DOM tree connections among JS wrapper objects. 
</div>
</div><p>
<a class="anchor" name="8e6f2e66c028d1ffa3f5e8a799790bc5"></a><!-- doxytag: member="v8::V8::AdjustAmountOfExternalAllocatedMemory" ref="8e6f2e66c028d1ffa3f5e8a799790bc5" args="(int change_in_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int v8::V8::AdjustAmountOfExternalAllocatedMemory           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>change_in_bytes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjusts the amount of registered external memory. Used to give <a class="el" href="classv8_1_1_v8.html">V8</a> an indication of the amount of externally allocated memory that is kept alive by JavaScript objects. <a class="el" href="classv8_1_1_v8.html">V8</a> uses this to decide when to perform global garbage collections. Registering externally allocated memory will trigger global garbage collections more often than otherwise in an attempt to garbage collect the JavaScript objects keeping the externally allocated memory alive.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>change_in_bytes</em>&nbsp;</td><td>the change in externally allocated memory that is kept alive by JavaScript objects. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the adjusted value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="06126bd2345c086a376f934ec1fbcce6"></a><!-- doxytag: member="v8::V8::ContextDisposedNotification" ref="06126bd2345c086a376f934ec1fbcce6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int v8::V8::ContextDisposedNotification           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optional notification that a context has been disposed. <a class="el" href="classv8_1_1_v8.html">V8</a> uses these notifications to guide the GC heuristic. Returns the number of context disposals - including this one - since the last time <a class="el" href="classv8_1_1_v8.html">V8</a> had a chance to clean up. 
</div>
</div><p>
<a class="anchor" name="566450d632c0a63770682b9da3cae08d"></a><!-- doxytag: member="v8::V8::Dispose" ref="566450d632c0a63770682b9da3cae08d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::Dispose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases any resources used by <a class="el" href="namespacev8.html">v8</a> and stops any utility threads that may be running. Note that disposing <a class="el" href="namespacev8.html">v8</a> is permanent, it cannot be reinitialized.<p>
It should generally not be necessary to dispose <a class="el" href="namespacev8.html">v8</a> before exiting a process, this should happen automatically. It is only necessary to use if the process needs the resources taken up by <a class="el" href="namespacev8.html">v8</a>. 
</div>
</div><p>
<a class="anchor" name="a91df5fe1bb98b87952ef4bbf0aceb96"></a><!-- doxytag: member="v8::V8::EnableSlidingStateWindow" ref="a91df5fe1bb98b87952ef4bbf0aceb96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::EnableSlidingStateWindow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the computation of a sliding window of states. The sliding window information is recorded in statistics counters. 
</div>
</div><p>
<a class="anchor" name="94e8ce52e976b58d5cbdb23d2abe894e"></a><!-- doxytag: member="v8::V8::GetActiveProfilerModules" ref="94e8ce52e976b58d5cbdb23d2abe894e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int v8::V8::GetActiveProfilerModules           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns active (resumed) profiler modules. See ProfilerModules enum.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>active profiler modules. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6b73813e84728c2a91f61ef45e48d80c"></a><!-- doxytag: member="v8::V8::GetCurrentThreadId" ref="6b73813e84728c2a91f61ef45e48d80c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int v8::V8::GetCurrentThreadId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the <a class="el" href="classv8_1_1_v8.html">V8</a> thread id of the calling thread.<p>
The thread id for a thread should only be retrieved after the <a class="el" href="classv8_1_1_v8.html">V8</a> lock has been acquired with a Locker object with that thread. 
</div>
</div><p>
<a class="anchor" name="63e014365648e568ae47b8a849dfc992"></a><!-- doxytag: member="v8::V8::GetHeapStatistics" ref="63e014365648e568ae47b8a849dfc992" args="(HeapStatistics *heap_statistics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::GetHeapStatistics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classv8_1_1_heap_statistics.html">HeapStatistics</a> *&nbsp;</td>
          <td class="paramname"> <em>heap_statistics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get statistics about the heap memory usage. 
</div>
</div><p>
<a class="anchor" name="c7e91e25ed7773db1f31413fb726bca7"></a><!-- doxytag: member="v8::V8::GetLogLines" ref="c7e91e25ed7773db1f31413fb726bca7" args="(int from_pos, char *dest_buf, int max_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int v8::V8::GetLogLines           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>from_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If logging is performed into a memory buffer (via --logfile=*), allows to retrieve previously written messages. This can be used for retrieving profiler log data in the application. This function is thread-safe.<p>
Caller provides a destination buffer that must exist during GetLogLines call. Only whole log lines are copied into the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>from_pos</em>&nbsp;</td><td>specified a point in a buffer to read from, 0 is the beginning of a buffer. It is assumed that caller updates its current position using returned size value from the previous call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_buf</em>&nbsp;</td><td>destination buffer for log data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_size</em>&nbsp;</td><td>size of the destination buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>actual size of log data copied into buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fcecc0e9e8b5fa17a06a93f7b5a7538d"></a><!-- doxytag: member="v8::V8::GetVersion" ref="fcecc0e9e8b5fa17a06a93f7b5a7538d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* v8::V8::GetVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the version string. 
</div>
</div><p>
<a class="anchor" name="f4ac685c915acf6325daafa70bae9835"></a><!-- doxytag: member="v8::V8::IdleNotification" ref="f4ac685c915acf6325daafa70bae9835" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::IdleNotification           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optional notification that the embedder is idle. <a class="el" href="classv8_1_1_v8.html">V8</a> uses the notification to reduce memory footprint. This call can be used repeatedly if the embedder remains idle. Returns true if the embedder should stop calling IdleNotification until real work has been done. This indicates that <a class="el" href="classv8_1_1_v8.html">V8</a> has done as much cleanup as it will be able to do. 
</div>
</div><p>
<a class="anchor" name="1058ff39b32a17976df1e2b75c3d1cb4"></a><!-- doxytag: member="v8::V8::IgnoreOutOfMemoryException" ref="1058ff39b32a17976df1e2b75c3d1cb4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::IgnoreOutOfMemoryException           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ignore out-of-memory exceptions.<p>
<a class="el" href="classv8_1_1_v8.html">V8</a> running out of memory is treated as a fatal error by default. This means that the fatal error handler is called and that <a class="el" href="classv8_1_1_v8.html">V8</a> is terminated.<p>
IgnoreOutOfMemoryException can be used to not treat a out-of-memory situation as a fatal error. This way, the contexts that did not cause the out of memory problem might be able to continue execution. 
</div>
</div><p>
<a class="anchor" name="40daec93ce44bdd922567fc121be9db8"></a><!-- doxytag: member="v8::V8::Initialize" ref="40daec93ce44bdd922567fc121be9db8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::Initialize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes from snapshot if possible. Otherwise, attempts to initialize from scratch. This function is called implicitly if you use the API without calling it first. 
</div>
</div><p>
<a class="anchor" name="0d5593ecf0d41035e4d9ee512119f0b7"></a><!-- doxytag: member="v8::V8::IsDead" ref="0d5593ecf0d41035e4d9ee512119f0b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::IsDead           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if <a class="el" href="classv8_1_1_v8.html">V8</a> is dead and therefore unusable. This is the case after fatal errors such as out-of-memory situations. 
</div>
</div><p>
<a class="anchor" name="eeffbebf5f753286eda3db8f14908ad7"></a><!-- doxytag: member="v8::V8::IsExecutionTerminating" ref="eeffbebf5f753286eda3db8f14908ad7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::IsExecutionTerminating           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is <a class="el" href="classv8_1_1_v8.html">V8</a> terminating JavaScript execution.<p>
Returns true if JavaScript execution is currently terminating because of a call to TerminateExecution. In that case there are still JavaScript frames on the stack and the termination exception is still active. 
</div>
</div><p>
<a class="anchor" name="a8dc5a7c3a059bb376882ac36b9df775"></a><!-- doxytag: member="v8::V8::IsProfilerPaused" ref="a8dc5a7c3a059bb376882ac36b9df775" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool v8::V8::IsProfilerPaused           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether profiler is currently paused. 
</div>
</div><p>
<a class="anchor" name="7df118b9667d04903f8e9fb7452fd1ac"></a><!-- doxytag: member="v8::V8::LowMemoryNotification" ref="7df118b9667d04903f8e9fb7452fd1ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::LowMemoryNotification           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optional notification that the system is running low on memory. <a class="el" href="classv8_1_1_v8.html">V8</a> uses these notifications to attempt to free memory. 
</div>
</div><p>
<a class="anchor" name="5fefebea0cd37105837a9d267baf2e5c"></a><!-- doxytag: member="v8::V8::PauseProfiler" ref="5fefebea0cd37105837a9d267baf2e5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::PauseProfiler           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspends recording of tick samples in the profiler. When the <a class="el" href="classv8_1_1_v8.html">V8</a> profiling mode is enabled (usually via command line switches) this function suspends recording of tick samples. Profiling ticks are discarded until <a class="el" href="classv8_1_1_v8.html#b0557aaba62c7fb253fe838003aa60af">ResumeProfiler()</a> is called.<p>
See also the --prof and --prof_auto command line switches to enable <a class="el" href="classv8_1_1_v8.html">V8</a> profiling. 
</div>
</div><p>
<a class="anchor" name="8078e3c6e4d38ef6e9142b76b0420d4e"></a><!-- doxytag: member="v8::V8::PauseProfilerEx" ref="8078e3c6e4d38ef6e9142b76b0420d4e" args="(int flags, int tag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::PauseProfilerEx           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pauses specified profiler modules. Each call to "PauseProfilerEx" closes a block of profiler events opened by a call to "ResumeProfilerEx" with the same tag value. There is no need for blocks to be properly nested. The profiler is paused when the last opened block is closed.<p>
"PauseProfiler" is equivalent to "PauseProfilerEx(PROFILER_MODULE_CPU)". See ProfilerModules enum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying profiler modules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Profile tag. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3382e4dae9865909242a8ee0b1d6bf77"></a><!-- doxytag: member="v8::V8::RemoveGCEpilogueCallback" ref="3382e4dae9865909242a8ee0b1d6bf77" args="(GCEpilogueCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::RemoveGCEpilogueCallback           </td>
          <td>(</td>
          <td class="paramtype">GCEpilogueCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function removes callback which was installed by AddGCEpilogueCallback function. 
</div>
</div><p>
<a class="anchor" name="7cdceb9c8ea5cd0887f69fd3bd97193f"></a><!-- doxytag: member="v8::V8::RemoveGCPrologueCallback" ref="7cdceb9c8ea5cd0887f69fd3bd97193f" args="(GCPrologueCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::RemoveGCPrologueCallback           </td>
          <td>(</td>
          <td class="paramtype">GCPrologueCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function removes callback which was installed by AddGCPrologueCallback function. 
</div>
</div><p>
<a class="anchor" name="024f57744e8dfdcb2ea1417024b4805c"></a><!-- doxytag: member="v8::V8::RemoveMessageListeners" ref="024f57744e8dfdcb2ea1417024b4805c" args="(MessageCallback that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::RemoveMessageListeners           </td>
          <td>(</td>
          <td class="paramtype">MessageCallback&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all message listeners from the specified callback function. 
</div>
</div><p>
<a class="anchor" name="b0557aaba62c7fb253fe838003aa60af"></a><!-- doxytag: member="v8::V8::ResumeProfiler" ref="b0557aaba62c7fb253fe838003aa60af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::ResumeProfiler           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resumes recording of tick samples in the profiler. See also <a class="el" href="classv8_1_1_v8.html#5fefebea0cd37105837a9d267baf2e5c">PauseProfiler()</a>. 
</div>
</div><p>
<a class="anchor" name="ffe7a421288278719a71928d3b9c4836"></a><!-- doxytag: member="v8::V8::ResumeProfilerEx" ref="ffe7a421288278719a71928d3b9c4836" args="(int flags, int tag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::ResumeProfilerEx           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resumes specified profiler modules. Can be called several times to mark the opening of a profiler events block with the given tag.<p>
"ResumeProfiler" is equivalent to "ResumeProfilerEx(PROFILER_MODULE_CPU)". See ProfilerModules enum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying profiler modules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Profile tag. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="830d3ba2704b6e7c361188b22318c0be"></a><!-- doxytag: member="v8::V8::SetCounterFunction" ref="830d3ba2704b6e7c361188b22318c0be" args="(CounterLookupCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetCounterFunction           </td>
          <td>(</td>
          <td class="paramtype">CounterLookupCallback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the host application to provide a mechanism for recording statistics counters. 
</div>
</div><p>
<a class="anchor" name="c4db0dff0f29c750d30fcac65c4d1968"></a><!-- doxytag: member="v8::V8::SetCreateHistogramFunction" ref="c4db0dff0f29c750d30fcac65c4d1968" args="(CreateHistogramCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetCreateHistogramFunction           </td>
          <td>(</td>
          <td class="paramtype">CreateHistogramCallback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the host application to provide a mechanism for recording histograms. The CreateHistogram function returns a histogram which will later be passed to the AddHistogramSample function. 
</div>
</div><p>
<a class="anchor" name="a6ed646d43360c209881871b3ac747aa"></a><!-- doxytag: member="v8::V8::SetFailedAccessCheckCallbackFunction" ref="a6ed646d43360c209881871b3ac747aa" args="(FailedAccessCheckCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetFailedAccessCheckCallbackFunction           </td>
          <td>(</td>
          <td class="paramtype">FailedAccessCheckCallback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback function for reporting failed access checks. 
</div>
</div><p>
<a class="anchor" name="b386f81a6d58dcf481d00446e8d15c9e"></a><!-- doxytag: member="v8::V8::SetFatalErrorHandler" ref="b386f81a6d58dcf481d00446e8d15c9e" args="(FatalErrorCallback that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetFatalErrorHandler           </td>
          <td>(</td>
          <td class="paramtype">FatalErrorCallback&nbsp;</td>
          <td class="paramname"> <em>that</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the callback to invoke in case of fatal errors. 
</div>
</div><p>
<a class="anchor" name="63157ad9284ffad1c0ab62b21aadd08c"></a><!-- doxytag: member="v8::V8::SetFlagsFromCommandLine" ref="63157ad9284ffad1c0ab62b21aadd08c" args="(int *argc, char **argv, bool remove_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetFlagsFromCommandLine           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>remove_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets <a class="el" href="classv8_1_1_v8.html">V8</a> flags from the command line. 
</div>
</div><p>
<a class="anchor" name="b263a85e6f97ea79d944bd20bb09a95f"></a><!-- doxytag: member="v8::V8::SetFlagsFromString" ref="b263a85e6f97ea79d944bd20bb09a95f" args="(const char *str, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetFlagsFromString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets <a class="el" href="classv8_1_1_v8.html">V8</a> flags from a string. 
</div>
</div><p>
<a class="anchor" name="94bac5e06a99141c5629842e18558cfe"></a><!-- doxytag: member="v8::V8::SetGlobalGCEpilogueCallback" ref="94bac5e06a99141c5629842e18558cfe" args="(GCCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetGlobalGCEpilogueCallback           </td>
          <td>(</td>
          <td class="paramtype">GCCallback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function is deprecated. Please use AddGCEpilogueCallback instead. Enables the host application to receive a notification after a major garbage collection. Allocations are not allowed in the callback function, you therefore cannot manipulate objects (set or delete properties for example) since it is possible such operations will result in the allocation of objects. 
</div>
</div><p>
<a class="anchor" name="503e14a77e922775bd88bc2e19e19886"></a><!-- doxytag: member="v8::V8::SetGlobalGCPrologueCallback" ref="503e14a77e922775bd88bc2e19e19886" args="(GCCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::SetGlobalGCPrologueCallback           </td>
          <td>(</td>
          <td class="paramtype">GCCallback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function is deprecated. Please use AddGCPrologueCallback instead. Enables the host application to receive a notification before a garbage collection. Allocations are not allowed in the callback function, you therefore cannot manipulate objects (set or delete properties for example) since it is possible such operations will result in the allocation of objects. 
</div>
</div><p>
<a class="anchor" name="7b09bb56f4effb91e1de4398c8fd43f2"></a><!-- doxytag: member="v8::V8::TerminateExecution" ref="7b09bb56f4effb91e1de4398c8fd43f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::TerminateExecution           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forcefully terminate the current thread of JavaScript execution.<p>
This method can be used by any thread even if that thread has not acquired the <a class="el" href="classv8_1_1_v8.html">V8</a> lock with a Locker object. 
</div>
</div><p>
<a class="anchor" name="f7d845e6f55eb76085d5ff3601780986"></a><!-- doxytag: member="v8::V8::TerminateExecution" ref="f7d845e6f55eb76085d5ff3601780986" args="(int thread_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void v8::V8::TerminateExecution           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>thread_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forcefully terminate execution of a JavaScript thread. This can be used to terminate long-running scripts.<p>
TerminateExecution should only be called when then <a class="el" href="classv8_1_1_v8.html">V8</a> lock has been acquired with a Locker object. Therefore, in order to be able to terminate long-running threads, preemption must be enabled to allow the user of TerminateExecution to acquire the lock.<p>
The termination is achieved by throwing an exception that is uncatchable by JavaScript exception handlers. Termination exceptions act as if they were caught by a C++ <a class="el" href="classv8_1_1_try_catch.html">TryCatch</a> exception handlers. If forceful termination is used, any C++ <a class="el" href="classv8_1_1_try_catch.html">TryCatch</a> exception handler that catches an exception should check if that exception is a termination exception and immediately return if that is the case. Returning immediately in that case will continue the propagation of the termination exception if needed.<p>
The thread id passed to TerminateExecution must have been obtained by calling GetCurrentThreadId on the thread in question.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread_id</em>&nbsp;</td><td>The thread id of the thread to terminate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="2bdde078c68d2820262925687b962553"></a><!-- doxytag: member="v8::V8::kMinimumSizeForLogLinesBuffer" ref="2bdde078c68d2820262925687b962553" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classv8_1_1_v8.html#2bdde078c68d2820262925687b962553">v8::V8::kMinimumSizeForLogLinesBuffer</a> = 2048<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The minimum allowed size for a log lines buffer. If the size of the buffer given will not be enough to hold a line of the maximum length, an attempt to find a log line end in GetLogLines will fail, and an empty result will be returned. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/home/riku/cornerstone/JS/v8-r4957/include/<a class="el" href="v8_8h-source.html">v8.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 28 13:06:50 2010 for v8 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
